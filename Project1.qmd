---
title: "Project 1 - API Census Data"
author: "Patrick Seebold"
format: html
editor: visual
---

## Setting up an API for Census Data

In this project, I will build an API to allow a user to access census data from â€“. First, let's grab the appropriate packages.

```{r}
library('jsonlite') # for handling json data from our APIs
library('tidyverse') # for those beautiful tibble functions
library('lubridate') # for dealing with the time variables
```

Before we start writing the functions that let our users specify custom APIs, let's go ahead and test out the 'usual method' covered in class to get make an API call. This will let us confirm that we can get the data we want without a key and investigate the format it returns our data in

```{r}
d = httr::GET(url = "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24")
str(d)
```

Looks like it worked! We now have a sample dataset in json format. We can use the jsonlite package to process this into a tibble, which will be more user-friendly for the our tidyverse methods.

```{r}
parsed = fromJSON(rawToChar(d$content))
parsed # check that the conversion out of JSON format worked
```

Great, we got the data into a character matrix using the method we discussed in class! However, we want it to be in a tibble, not in a matrix. Let's go ahead and make a function that will let us convert GET() output into tibble format:

```{r}
tibble_maker = function(input_url, tibble_name){
  d = httr::GET(input_url) # get the data from the URL
  parse = fromJSON(rawToChar(d$content)) # convert this our of JSON format
  colnames(parse) = parse[1,] # names are in the first row, so grab these
  tibble_name = as_tibble(parse, .name_repairs = 'unique') # specify rownames are in matrix
  tibble_name = tibble_name[-1,]# drop the row which has the tibble names in it
  return(tibble_name)
}

```

We needed to do some extra edits in our function to make sure that we get the variable names in the right place, but after some trial and error, we got it! Now we test the function to confirm it works:

```{r}
tibble_maker("https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24", test_tibble)
```

Great, we now have the tibble_maker() function which will take API census data and convert it into the desired tibble format. Next, we can proceed to work on the function that allows a user to specify how to adjust their API call. We want to include:

-   Year (2022 as default, 2010 - 2022 as options)

-   Numeric Variables (AGEP, PWGTP as default. Options are AGEP, GASP, GRPIP, JWAP, JWDP, and JWMNP. PWGTP and one other Numeric variable must be returned)

-   Categorical Variables (SEX as default. Options are FER, HHL, HISPEED, JWTRNS, SCH, SCHL, and SEX. One categorical variable must be returned)

-   Location - State 19 as default, options are ALL, REGION, DIVISION, STATE.

```{r}
one_year_api = function(year = 2022, num = 'AGEP', cat = 'SEX', loc = "STATE:19"){
  
  # set the accepted values for each type of variable
  num_list = c('AGEP', 'GASP', 'GRPIP', 'JWAP', 'JWDP','JWMNP') 
  cat_list = c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL','SEX')
  loc_list = c('ALL', 'REGION','DIVISION', 'STATE','')
 
  # check that provided values match options
   if (between(year,2010,2022)){
    print('Year is in range')} else {
      stop('Year must be between 2010 - 2022')
    }
  
  if (num %in% num_list){
    print('Numerical variable selected')} else {
      stop('Make sure numerical variable is in list: AGEP, GASP, GRPIP, JWAP, JWDP, JWMNP')
    }
  
  if (cat %in% cat_list){
    print('Categorical variable selected')} else {
      stop('Make sure the (1) categorical variable is in list: FER, HHL, HISPEED, JWAP, JWDP, JWTRNS, SCH, SCHL,SEX')
    }
  
  #if (loc %in% loc_list){
  #  print('Location variable selected')} else {
  #    stop('Location must be (1) from list: ALL, DIVISION, REGION, STATE')
  #}
  
  # now that we have everything appropriately selected, we can write the API call
  if (loc == "ALL"){ # if we don't specify location, no need for specifying where
  api_url = as.character(paste('https://api.census.gov/data/',year,'/acs/acs1/pums?get=',num,',',cat,',PWGTP', sep=''))
  } else { # if location != ALL, set location at end of API call
  api_url = as.character(paste('https://api.census.gov/data/',year,'/acs/acs1/pums?get=',num,',',cat,',PWGTP','&for=',tolower(loc), sep=''))
  }
  # check that our url looks correct
  print(api_url)
  returned_tibble = tibble_maker(api_url, test_tibble)
  returned_tibble[[1]] = as.numeric(returned_tibble[[1]]) # specify correct variable type by column;
  returned_tibble[[2]] = as.factor(returned_tibble[[2]])  # we can do this by indexing since we know
  returned_tibble[[3]] = as.numeric(returned_tibble[[3]])
  # if (num == "JWAP"){
        }
```

Cool, now we have a function that gives us some customizable options for calling from the census API! However, it is possible that we want data from more than 1 year. Let's write another function that wraps around our one_year_api() function so that we can get a tibble with up to four years of data:

```{r}
multi_year_api(year = c(2022, 1000, 1000), num="JWAP", cat = "SEX", loc = "DIVISION")

```

```{r}
# This code block based on example provided by Dr. J. Post:
    temp = httr::GET("https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json")
    #turn it into a list
    temp_list = temp$content |> rawToChar() |>jsonlite::fromJSON()
    #grab just the names of JWAP and their values
    
    
convert_to_time = function(input_vec){ # change given vector to time
    JWAP = temp_list$values$item
    #reorder just so it is clearer
    JWAP_values = JWAP[sort(names(JWAP))]
    parsed_JWAP = c() # initialize an empty vector
    df = c()
    for (i in 1:length(JWAP_values)){
      df[i] = JWAP_values[[i]]
    }
    df = data.frame(df)
    df = df[-1,]
    df = data.frame(df)
    parsed_JWAP = separate_wider_delim(df, cols = everything(), delim = " ", names_sep = "")
    parsed_JWAP = parsed_JWAP[-c(2,3,5)]
    return(parsed_JWAP)
}

calculate_minutes_to_midnight = function(input_df){ # take parsed JW-P data
  df=c()                              # return min from midnight to int midpoint
  df$a = hm(input_df$df1) # convert to hour minute notation!
  df$b = hm(input_df$df4)
  df = as.data.frame(df)
  
  df$dif = df$b - df$a # calculate the number of mins in each interval
  
  df$interval_length = as.numeric(df$dif) # make values numeric for easier math
  df$interval_length = df$interval_length/60 # put back into minutes
  df$interval_midpoint = df$interval_length/2 # this gives us the midpoint 
  for (i in 1:nrow(df)){ # loop through data, calculating midnight from midnight
    if (i == 1){
      df$minutes_from_md_to_interval_start[i] = 0
      df$minutes_from_md_to_interval_midpoint[i] = 2
    } else {
    df$minutes_from_md_to_interval_start[i] = 1 + 
      df$minutes_from_md_to_interval_start[i-1] +
      df$interval_length[i-1]
    df$minutes_from_md_to_interval_midpoint[i] =
      df$minutes_from_md_to_interval_start[i] + df$interval_midpoint[i]
    }
  }
  return(as.data.frame(df$minutes_from_md_to_interval_midpoint))
}
test1 = convert_to_time(temp_list)
test= calculate_minutes_to_midnight(test1)
test
```

```{r}
one_year_api()



summary.census <- function(tibble, num_var, cat_var){
sum = sum(num_var*)
sum}


```

summary.census \<- function(tibble, num_var, cat_var){

sum}
